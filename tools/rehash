#!/usr/bin/env perl
#
# Copyright (c) 1994-2012 Carnegie Mellon University.  All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in
#    the documentation and/or other materials provided with the
#    distribution.
#
# 3. The name "Carnegie Mellon University" must not be used to
#    endorse or promote products derived from this software without
#    prior written permission. For permission or any legal
#    details, please contact
#      Carnegie Mellon University
#      Center for Technology Transfer and Enterprise Creation
#      4615 Forbes Avenue
#      Suite 302
#      Pittsburgh, PA  15213
#      (412) 268-7393, fax: (412) 268-7395
#      innovation@andrew.cmu.edu
#
# 4. Redistributions of any form whatsoever must retain the following
#    acknowledgment:
#    "This product includes software developed by Computing Services
#     at Carnegie Mellon University (http://www.cmu.edu/computing/)."
#
# CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
# THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
# FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
# AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
# OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use Math::BigInt;

$| = 1;

# options
my ($interactive, $force);

die "must not run as root" if ($< == 0);

unless (@ARGV) {
    usage();
}
if ("-i" eq $ARGV[0]) {
    $interactive = 1;
    shift @ARGV;
}
if ("-f" eq $ARGV[0]) {
    $force = 1;
    shift @ARGV;
}
if ("-h" eq $ARGV[0]) {
    usage();
}

my $MOVE_DOMAIN_CONF = 1;
my $MOVE_DOMAIN_SIEVE = 2;
my $MOVE_DOMAIN_PART = 3;

my ($tonone, $tobasic, $tofull);

$tonone = 1 if ("none" eq $ARGV[0]);
$tobasic = 1 if ("basic" eq $ARGV[0]);
$tofull = 1 if ("full" eq $ARGV[0]);
unless ($tonone || $tobasic || $tofull) {
    print "rehash: one of none/basic/full required\n";
    exit;
}
shift @ARGV;

my @bdirs = ("a".."z");
my @fdirs = ("A".."W");
my %ishash = map { $_ => 1 } (@bdirs, @fdirs);

my $imapdconf = shift || "/etc/imapd.conf";

# evil globals
my @configs;
my $confdir;
my @parts;
my $yn = "y";
my $sievedir = "/usr/sieve";
my $nosievedir = 0;
my $hashispool = 0;
my $virtdomains = 0;

push @configs, $imapdconf;

while (my $conf = shift @configs) {
    read_conf($conf);
}

if (! $confdir) { $confdir = "/var/imap"; }

if ($interactive) {
    print "upgrade $confdir? ";
    $yn = <STDIN>;
}
if ($yn =~ /^y/) {
    unless (-d $confdir) {
print "creating $confdir...\n";
	mkdir $confdir, 0755;
    }
    print "converting configuration directory $confdir...";
    chdir $confdir or die "couldn't change to $confdir";
    
    foreach my $i ("user", "proc", "lock", "db", "socket", "log", "msg", "quota") {
	unless (-d $i) {
	    print "creating $i...\n";
	    mkdir $i, 0755;
	}
    }

    # *** rehash the domain subdirectory to the new format,
    # don't worry about internal format yet
    if($virtdomains) {
	print "domain ";
	chdir "domain" or die "couldn't change to domain subdir";
	&move_domains($MOVE_DOMAIN_CONF);
	chdir "..";
    }

    # *** user subdirectory; holds subscription files
    print "user ";
    chdir "user" or die "couldn't change to user subdir";
    &move_users;
    chdir "..";
    
    # *** quota subdirectory; holds quota files for each quotaroot
    print "quota ";
    chdir "quota" or die "couldn't change to quota subdir";
    &move_quotas;
    print "done\n";
}

# create the sieve stuff
unless ($nosievedir) {
    print "converting $sievedir...\n";

    mkdir $sievedir, 0755;
    if (chdir $sievedir) {
        &move_sieve;
    }
}

# *** now for each data partition
while (my $part = shift @parts) {
    if ($interactive) {
	print "upgrade $part? ";
	$yn = <STDIN>;
    }
    if ($yn =~ /^y/) {
	unless (-d $part) {
	    print "creating $part...\n";
	    mkdir $part, 0755;
	}
	print "converting data partition $part...";
	chdir $part or die "couldn't chdir to $part";

	if ($hashispool) {
	    &move_part;

	    chdir $part or die "couldn't chdir to $part";
	    mkdir "stage.", 0755;
	}
    
	print "done\n";
    }
}

sub usage {
    print "usage: rehash [-i] [-f] none|basic|full [imapd.conf]\n";
    print "       -i interactive\n";
    print "       -f keep going on errors\n";
    exit;
}

sub ouch {
    my $msg = shift;

    if ($force) {
	print "fatal error: $msg\n";
    } else {
	print "error: $msg\n";
	exit 1;
    }
}

# force 32 bit
sub dir_hash_c {
    my $name = shift;

    my ($h, $n);

    if ($tofull) {
	$name =~ s/\..*//; # remove trailing dots
	$n = 0;
	foreach my $b (split(/ */, $name)) {
	    $n = (($n << 3) ^ ($n >> 5)) ^ ord($b);
	    $n &= 4294967295; # UINT32_MAX
	}
	$h = chr(ord('A') + ($n % 23));
	return $h;
    }
    elsif ($tobasic) {
	$h = lc(substr($name, 0, 1));
	if (!($h =~ /[a-z]/)) { $h = 'q'; }
	return $h;
    }
}

sub read_conf {
    my $file = shift;

    open CONF, $file or die "can't open $file";
    while (<CONF>) {
	if (/^#/) { 
	    next; 
	}
	if (/\@include:\s+(.*)$/) {
	    push @configs, $1;
	}
	if (/^configdirectory:\s+(.*)$/) {
	    $confdir = $1;
	}
	if (/^(?:meta)?partition-.*:\s+(.*)$/) {
	    if (grep /$1/, @parts) {
		next;
	    }
	    push @parts, $1;
	}
	if (/^hashimapspool:\s*(1|t|yes|on)/) {
	    $hashispool = 1;
	    print "i will also hash partitions.\n";
	}
        if (/^sieveusehomedir:\s+(1|t|yes|on)/) {
	    $nosievedir = 1;
	    print "you are storing sieve scripts in user's home directories.\n";
        }
        if (/^sievedir:\s+(.*)$/) {
	    $sievedir = $1;
	    print "you are using $sievedir as your sieve directory.\n";
        }
        if (/^virtdomains:\s+(1|t|yes|on)/) {
	    $virtdomains = 1;
	    print "i will deal with virtual domains.\n";
        }
    }
    close CONF;
}

sub do_subdomain_conf {
    if(-d "quota") {
	chdir "quota";
	move_quotas();
	chdir "..";
    }
    if(-d "user") {
	chdir "user";
	move_users();
	chdir "..";
    }
}

sub add_found {
    # here be dragons, eep
    my $ispart = shift;
    my $found = shift;
    my $name = shift;
    my $location = shift;

    unless ($ispart) {
	if ($found->{$name}) {
	    die "IN $ENV{PWD} FOUND BOTH $found->{$name} and $location - you need to fix this by hand\n";
	}
	$found->{$name} = $location;
	return;
    }

    opendir(SUB, $location) or ouch "Failed to open $ENV{PWD}/$location";
    while (my $sub = readdir SUB) {
	next if $sub =~ m/^\./;
	my $key = "$name/$sub";
	if ($found->{$key}) {
	    die "IN $ENV{PWD} FOUND BOTH $found->{$key} and $location/$sub - you need to fix this by hand\n";
	}
	$found->{$key} = "$location/$sub";
    }
    closedir(SUB);
}

sub find_items {
    my $ispart = shift;
    my %found;
    my @subs;

    opendir(ITEMS, ".") or ouch "couldn't read $ENV{PWD}";
    while (my $item = readdir ITEMS) {
	# guaranteed evil
	next if $item =~ m/^\./;
	next if $item eq 'lost+found';
	next if $item eq 'stage.';
	next if $item eq 'sync.';

	if ($ishash{$item}) {
	    push @subs, $item;
	}
	else {
	    add_found($ispart, \%found, $item, $item);
	}
    }
    closedir(ITEMS);

    foreach my $sub (@subs) {
	next unless opendir(ITEMS, $sub);
	while (my $item = readdir ITEMS) {
	    next if $item =~ m/^\./;
	    # we can't fix duplicate directories ourselves!
	    add_found($ispart, \%found, $item, "$sub/$item");
	}
	closedir(ITEMS);
    }

    return %found;
}

sub tidydir {
    my $onemore = shift;
    my $dir = shift;

    if ($onemore) {
	if (opendir(DIR, $dir)) {
	    while (my $item = readdir DIR) {
		next if $item =~ m/^\./;
		rmdir("$dir/$item");
	    }
	    closedir(DIR);
	}
    }

    rmdir($dir);
}

sub tidy_up {
    my $onemore = shift;
    unless ($tofull) {
	tidydir($onemore, $_) for @fdirs;
    }
    unless ($tobasic) {
	tidydir($onemore, $_) for @bdirs;
    }
}

sub ensurepath {
    my $path = shift;
    return unless $path =~ s{/[^/]+$}{}; # gotta trim something!
    unless (-d $path) {
	ensurepath($path);
	mkdir($path, 0755);
    }
}

sub do_moves {
    my $skiptochar = shift;
    my %found = @_;

    my $hashfn = sub {
	my $item = shift;
	return $item if $tonone;
	my $tohash = $item;
	if ($skiptochar) {
	    # strip up to and including the character
	    $tohash =~ s/^.*?\Q$skiptochar//;
	}
	return dir_hash_c($tohash) . "/$item";
    };

    foreach my $item (sort keys %found) {
	my $src = $found{$item};
	my $dst = $hashfn->($item);

	if ($src ne $dst) {
	    ensurepath($dst);
	    rename($src, $dst) or ouch "failed to rename $src to $dst";
	}
    }

    tidy_up();
}

sub move_domains {
    my $type_of_move = shift || die "move_domains called badly";

    my %found = find_items();

    do_moves(undef, %found);

    # let's do the subdirs
    foreach my $item (sort keys %found) {
	chdir ($found{$item});

	if ($type_of_move == $MOVE_DOMAIN_CONF) {
	    &do_subdomain_conf;
	} elsif ($type_of_move == $MOVE_DOMAIN_SIEVE) {
	    &move_sieve;
	} elsif ($type_of_move == $MOVE_DOMAIN_PART) {
	    &move_part;
	} else {
	    die "bad domain move mode: $type_of_move";
	}
    }
}

sub move_users {
    my %found = find_items();
    do_moves(undef, %found);
}

sub move_quotas {
    my %found = find_items();
    do_moves('.', %found);
}

sub move_sieve {
    my $do_domain = 0;

    my %found = find_items();

    if (delete $found{'domain'}) {
	$do_domain = 1;
    }

    do_moves(undef, %found);

    if ($do_domain) {
	chdir('domain');
	&move_domains($MOVE_DOMAIN_SIEVE);
    }
}

sub move_part {
    my $do_domain = 0;
    # let's just assume nobody is being stupid and creating 1 character toplevel names
    my %found = find_items(1);

    if (delete $found{'domain'}) {
	$do_domain = 1;
    }

    do_moves('/', %found);
    # extra level of tidying
    tidy_up(1);

    if ($do_domain) {
	chdir('domain');
	move_domains($MOVE_DOMAIN_PART);
    }
}
