#include <config.h>

#include <string.h>
#include <unistd.h>
#include <utime.h>

#include <sys/types.h>
#include <sys/stat.h>

#include "lib/exitcodes.h"
#include "lib/lock_file.h"
#include "lib/util.h"
#include "lib/xmalloc.h"

#include "cunit/cunit.h"

/*
 * copy of (private) definition of struct lockf, so we can inspect
 * the innards
 */
struct lockf {
    char *filename;
    int fd;
    struct timespec ts;
};

static char *make_filename(const char *test_name)
{
    char *filename = strconcat("/tmp/cunit-", test_name, "-XXXXXX", NULL);
    return mktemp(filename);
}

static int make_fakelock(const char *filename, time_t mtime)
{
    int fake_pid;
    do {
        fake_pid = 1000 + rand() % 31768;
    } while (fake_pid == getpid());

    FILE *f = fopen(filename, "w");
    if (!f) return -1;

    fprintf(f, "%d\n", fake_pid);
    fclose(f);

    if (mtime > 0) {
        struct utimbuf utimbuf;
        utimbuf.actime = utimbuf.modtime = mtime;
        int r = utime(filename, &utimbuf);
        if (r) {
            unlink(filename);
            return r;
        }
    }

    return 0;
}

static int file_exists(const char *filename)
{
    struct stat sbuf;

    int r = stat(filename, &sbuf);
    if (!r) return 1;
    if (errno == ENOENT) return 0;

    return -1;
}

static void test_non_pathological_case(void)
{
    char *filename = make_filename(__func__);
    CU_ASSERT_EQUAL_FATAL(file_exists(filename), 0);

    struct lockf *lf = lf_lock(filename);
    CU_ASSERT_PTR_NOT_NULL_FATAL(lf);
    CU_ASSERT_STRING_EQUAL(lf->filename, filename);
    CU_ASSERT_NOT_EQUAL(lf->fd, -1);
    CU_ASSERT_NOT_EQUAL(lf->ts.tv_sec, 0);
    CU_ASSERT_EQUAL(file_exists(filename), 1);

    struct timespec orig_ts;
    memcpy(&orig_ts, &lf->ts, sizeof(orig_ts));

    CU_ASSERT_EQUAL(lf_ismine(lf), 1);

    const int delay = 2;
    sleep(delay); // wait a bit so that a touch will bump the timestamp

    struct timespec ts;
    time_t age = lf_age(lf, &ts);
    CU_ASSERT(age > delay - 1);
    CU_ASSERT(age <= delay + 1);
    CU_ASSERT_EQUAL(ts.tv_sec, age);
    CU_ASSERT_EQUAL(ts.tv_nsec, 0);

    int r = lf_touch(lf);
    CU_ASSERT_EQUAL(r, 0);
    CU_ASSERT(lf->ts.tv_sec > orig_ts.tv_sec);

    r = lf_unlock(&lf);
    CU_ASSERT_EQUAL(r, 0);
    CU_ASSERT_PTR_NULL(lf);
    CU_ASSERT_EQUAL(file_exists(filename), 0);

    free(filename);
}

static void test_deadlock_detection(void)
{
    char *filename = make_filename(__func__);
    CU_ASSERT_EQUAL_FATAL(file_exists(filename), 0);

    struct lockf *lf = lf_lock(filename);
    CU_ASSERT_PTR_NOT_NULL_FATAL(lf);
    CU_ASSERT_STRING_EQUAL(lf->filename, filename);
    CU_ASSERT_NOT_EQUAL(lf->fd, -1);
    CU_ASSERT_NOT_EQUAL(lf->ts.tv_sec, 0);
    CU_ASSERT_EQUAL(file_exists(filename), 1);

    struct buf expect_fatal = BUF_INITIALIZER;
    buf_printf(&expect_fatal, "deadlock detected: trying to lock %s twice from pid %i\n",
                filename, getpid());

    CU_EXPECT_CYRFATAL_BEGIN;
        struct lockf *boom = lf_lock(filename);
        (void) boom; /* circumvent "unused" warning */
    CU_EXPECT_CYRFATAL_END(EC_SOFTWARE, buf_release(&expect_fatal));

    int r = lf_unlock(&lf);
    CU_ASSERT_EQUAL(r, 0);
    CU_ASSERT_PTR_NULL(lf);
    CU_ASSERT_EQUAL(file_exists(filename), 0);

    free(filename);
}

static void test_timeout_detection(void)
{
    char *filename = make_filename(__func__);
    CU_ASSERT_EQUAL_FATAL(file_exists(filename), 0);

    make_fakelock(filename, 0);
    CU_ASSERT_EQUAL_FATAL(file_exists(filename), 1);

    unsigned int slmatch = CU_SYSLOG_MATCH("timed out while attempting to lock");
    struct lockf *lf = lf_lock(filename);
    CU_ASSERT_PTR_NULL_FATAL(lf);
    CU_ASSERT_SYSLOG(slmatch, 1);

    unlink(filename);
    free(filename);
}

static void test_state_lock_detection(void)
{
    char *filename = make_filename(__func__);
    CU_ASSERT_EQUAL_FATAL(file_exists(filename), 0);

    make_fakelock(filename, time(0) - 25);
    CU_ASSERT_EQUAL_FATAL(file_exists(filename), 1);

    unsigned int slmatch1 = CU_SYSLOG_MATCH("stale lock file detected:");
    unsigned int slmatch2 = CU_SYSLOG_MATCH("timed out while attempting to lock");
    struct lockf *lf = lf_lock(filename);
    CU_ASSERT_PTR_NULL_FATAL(lf);
    CU_ASSERT_SYSLOG(slmatch1, 1);
    CU_ASSERT_SYSLOG(slmatch2, 1);

    unlink(filename);
    free(filename);
}

static void test_meddling_detection(void)
{
    char *filename = make_filename(__func__);
    CU_ASSERT_EQUAL_FATAL(file_exists(filename), 0);

    struct lockf *lf = lf_lock(filename);
    CU_ASSERT_PTR_NOT_NULL_FATAL(lf);

    sleep(2);

    struct utimbuf utimbuf;
    utimbuf.actime = utimbuf.modtime = time(0);
    int r = utime(filename, &utimbuf);
    if (r) {
        CU_FAIL("couldn't meddle with lock file, unable to test");
        lf_unlock(&lf);
        return;
    }

    CU_ASSERT_EQUAL(lf_ismine(lf), 0);

    struct buf expect_fatal = BUF_INITIALIZER;
    buf_printf(&expect_fatal, "lf_touch: lock no longer ours: %s", lf->filename);
    CU_EXPECT_CYRFATAL_BEGIN;
        lf_touch(lf);
    CU_EXPECT_CYRFATAL_END(EC_SOFTWARE, buf_cstring(&expect_fatal));

    buf_reset(&expect_fatal);
    buf_printf(&expect_fatal, "lf_unlock: lock no longer ours: %s", lf->filename);
    CU_EXPECT_CYRFATAL_BEGIN;
        lf_unlock(&lf);
    CU_EXPECT_CYRFATAL_END(EC_SOFTWARE, buf_cstring(&expect_fatal));
    buf_free(&expect_fatal);

    unlink(filename);
    free(filename);
}

static void test_rename_detection(void)
{
    char *filename = make_filename(__func__);
    CU_ASSERT_EQUAL_FATAL(file_exists(filename), 0);

    struct lockf *lf = lf_lock(filename);
    CU_ASSERT_PTR_NOT_NULL_FATAL(lf);

    sleep(2);

    char *newname = strconcat(filename, ".new", NULL);
    int r = rename(filename, newname);
    if (r) {
        CU_FAIL("couldn't meddle with lock file, unable to test");
        lf_unlock(&lf);
        return;
    }

    CU_ASSERT_EQUAL(lf_ismine(lf), 0);

    struct buf expect_fatal = BUF_INITIALIZER;
    buf_printf(&expect_fatal, "lf_touch: lock no longer ours: %s", lf->filename);
    CU_EXPECT_CYRFATAL_BEGIN;
        lf_touch(lf);
    CU_EXPECT_CYRFATAL_END(EC_SOFTWARE, buf_cstring(&expect_fatal));

    buf_reset(&expect_fatal);
    buf_printf(&expect_fatal, "lf_unlock: lock no longer ours: %s", lf->filename);
    CU_EXPECT_CYRFATAL_BEGIN;
        lf_unlock(&lf);
    CU_EXPECT_CYRFATAL_END(EC_SOFTWARE, buf_cstring(&expect_fatal));
    buf_free(&expect_fatal);

    unlink(filename);
    unlink(newname);

    free(filename);
    free(newname);
}
